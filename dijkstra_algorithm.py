# -*- coding: utf-8 -*-
"""Dijkstra algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kLuQX4yKikjpVOR8X9OAmmiF9pptt5pd
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
import heapq
import tqdm

INFINITE = 9999999999
# float('inf')


file = 'maze.png'
file2 = 'maze5.jpg'

RED = (255, 0, 0)
BLUE = (0, 0, 255)
GREEN = (0, 255, 0)
# START_POINT = (220, 5)
# END_POINT = (5, 20)
START_POINT = (315, 20)
END_POINT = (342, 311)

img = cv2.imread(file2)  # read an image from a file using
cv2.circle(img, START_POINT, 3, RED, -1)  # add a circle at (5, 220)
cv2.circle(img, END_POINT, 3, BLUE, -1)  # add a circle at (5,5)

# Your Code Should Be Here
WIDTH, HEIGHT = img.shape[0:2]
print('width  =', WIDTH, 'height = ', HEIGHT)


def prefer(math):
    math = math[:, :, 0]
    math = math // 200
    math = math * INFINITE
    return math


def in_rang(x, y):
    return WIDTH > x >= 0 and HEIGHT > y >= 0


def get_neighbors(math, x, y):
    neighbors = []
    for i in range(-1, 2):
        for j in range(-1, 2):
            if in_rang(x + i, y + j):
                if bool(math[x + i, y + j]) and not (i == 0 and j == 0):
                    neighbors.append((x + i, y + j))
    return neighbors


def resque(math, start, neighbor, heap_min, parent_path):
    """resque and return val of call """
    cost = cost_distans(start, neighbor)
    distans = cost + math[start]
    if math[neighbor] > distans:
        parent_path[neighbor] = start
        heapq.heappush(heap_min, (distans, neighbor))
        math[neighbor] = distans
    return math[neighbor]


def cost_distans(start, neighbor):
    """calculate Pitagoras :return distans """
    return ((start[0] - neighbor[0]) ** 2 + (start[1] - neighbor[1]) ** 2) ** .5


def dijkstra(math, start_point, end_point):
    math = prefer(math)
    math[start_point] = 0

    heap_min = []
    visited = set()
    parent_path = {}

    h, w = math.shape
    progress = tqdm.tqdm(total=h * w)
    point = start_point

    while end_point != point:
        progress.update(1)
        visited.add(point)
        for neighbor in get_neighbors(math, *point):
            if neighbor not in visited:
                resque(math, point, neighbor, heap_min, parent_path)
        _, point = heapq.heappop(heap_min)
    return get_path(end_point, start_point, parent_path), visited


def mark_visited(img, nodes):
    for i, j in nodes:
        img[i, j] = BLUE


def get_path(end_point, start_point, parent_path):
    path = []
    node = end_point
    while node != start_point:
        path.append(node)
        node = parent_path[node]
    return path[::-1]


def drawPath(img, path, thickness=3):
    '''path is a list of (x,y) tuples'''
    x0, y0 = path[0]
    for vertex in path[1:]:
        x1, y1 = vertex
        cv2.line(img, (y0, x0), (y1, x1), RED, thickness)
        x0, y0 = vertex


path, visited = dijkstra(img, START_POINT, END_POINT)
# img = cv2.imread(file2)
mark_visited(img, visited)
drawPath(img, path)

plt.figure(figsize=(10, 10))
plt.imshow(img)  # show the image on the screen
plt.show()
